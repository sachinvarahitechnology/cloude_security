"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformActivities = void 0;
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../../errors");
const events_1 = require("../../events");
const model_1 = require("../../model");
const Interaction_1 = require("../Interaction");
const index_1 = require("./index");
/**
 * An {@apilink Ability} that enables an {@apilink Actor} to perform a given {@apilink Activity}.
 *
 * {@apilink PerformActivities} is used internally by {@apilink Actor.perform}, and it is unlikely you'll ever need to use it directly in your code.
 * That is, unless you're building a custom Serenity/JS extension and want to override the default behaviour of the framework,
 * in which case you should check out the [Contributor's Guide](/contributing).
 *
 * @group Abilities
 */
class PerformActivities extends index_1.Ability {
    constructor(actor, stage) {
        super();
        this.actor = actor;
        this.stage = stage;
    }
    async perform(activity) {
        const sceneId = this.stage.currentSceneId();
        const details = this.detailsOf(activity);
        const activityId = this.stage.assignNewActivityId(details);
        const [activityStarts, activityFinished] = activity instanceof Interaction_1.Interaction
            ? [events_1.InteractionStarts, events_1.InteractionFinished]
            : [events_1.TaskStarts, events_1.TaskFinished];
        try {
            this.stage.announce(new activityStarts(sceneId, activityId, details, this.stage.currentTime()));
            await activity.performAs(this.actor);
            this.stage.announce(new activityFinished(sceneId, activityId, details, new model_1.ExecutionSuccessful(), this.stage.currentTime()));
        }
        catch (error) {
            this.stage.announce(new activityFinished(sceneId, activityId, details, this.outcomeFor(error), this.stage.currentTime()));
            throw error;
        }
        finally {
            await this.stage.waitForNextCue();
        }
    }
    outcomeFor(error) {
        return (0, tiny_types_1.match)(error)
            .when(errors_1.ImplementationPendingError, _ => new model_1.ImplementationPending(error))
            .when(errors_1.TestCompromisedError, _ => new model_1.ExecutionCompromised(error))
            .when(errors_1.AssertionError, _ => new model_1.ExecutionFailedWithAssertionError(error))
            .when(Error, _ => /AssertionError/.test(error.constructor.name) // mocha
            ? new model_1.ExecutionFailedWithAssertionError(error)
            : new model_1.ExecutionFailedWithError(error))
            .else(_ => new model_1.ExecutionFailedWithError(error));
    }
    detailsOf(activity) {
        return new model_1.ActivityDetails(new model_1.Name(this.nameOf(activity)), activity.instantiationLocation());
    }
    nameOf(activity) {
        const template = activity.toString() === ({}).toString()
            ? `#actor performs ${activity.constructor.name}`
            : activity.toString();
        return template.replace('#actor', this.actor.name);
    }
}
exports.PerformActivities = PerformActivities;
//# sourceMappingURL=PerformActivities.js.map