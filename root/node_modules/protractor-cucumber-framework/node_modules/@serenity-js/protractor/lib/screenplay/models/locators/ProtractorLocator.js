"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtractorExistingElementLocator = exports.ProtractorLocator = void 0;
const web_1 = require("@serenity-js/web");
const promised_1 = require("../../promised");
const unpromisedWebElement_1 = require("../../unpromisedWebElement");
const ProtractorPageElement_1 = require("../ProtractorPageElement");
const ProtractorSelectors_1 = require("./ProtractorSelectors");
/**
 * Protractor-specific implementation of {@apilink Locator}.
 *
 * @group Models
 */
class ProtractorLocator extends web_1.Locator {
    constructor(parent, selector, errorHandler) {
        super(parent, selector);
        this.errorHandler = errorHandler;
    }
    nativeSelector() {
        return ProtractorSelectors_1.ProtractorSelectors.locatorFrom(this.selector);
    }
    async isPresent() {
        try {
            const element = await this.resolveNativeElement();
            return Boolean(element);
        }
        catch {
            return false;
        }
    }
    async nativeElement() {
        try {
            return await this.resolveNativeElement();
        }
        catch (error) {
            return await this.errorHandler.executeIfHandled(error, () => this.resolveNativeElement());
        }
    }
    async resolveNativeElement() {
        const parent = await this.parent.nativeElement();
        const result = await (0, unpromisedWebElement_1.unpromisedWebElement)(parent.element(this.nativeSelector()));
        // checks if the element can be interacted with; in particular, throws unexpected alert present if there is one
        await result.isPresent();
        return result;
    }
    async allNativeElements() {
        const parent = await this.parent.nativeElement();
        return parent.all(this.nativeSelector());
    }
    of(parent) {
        return new ProtractorLocator(parent, this.selector, this.errorHandler);
    }
    closestTo(child) {
        return new ProtractorParentElementLocator(this.parent, this.selector, child, this.errorHandler);
    }
    locate(child) {
        return new ProtractorLocator(this, child.selector, this.errorHandler);
    }
    element() {
        return new ProtractorPageElement_1.ProtractorPageElement(this);
    }
    async allElements() {
        const elements = await this.allNativeElements();
        return Promise.all(elements.map(childElement => new ProtractorPageElement_1.ProtractorPageElement(new ProtractorExistingElementLocator(this.parent, this.selector, this.errorHandler, (0, unpromisedWebElement_1.unpromisedWebElement)(childElement)))));
    }
}
exports.ProtractorLocator = ProtractorLocator;
/**
 * @internal
 */
class ProtractorExistingElementLocator extends ProtractorLocator {
    constructor(parent, selector, errorHandler, existingNativeElement) {
        super(parent, selector, errorHandler);
        this.existingNativeElement = existingNativeElement;
    }
    async nativeElement() {
        return this.existingNativeElement;
    }
    async allNativeElements() {
        return [this.existingNativeElement];
    }
}
exports.ProtractorExistingElementLocator = ProtractorExistingElementLocator;
class ProtractorParentElementLocator extends ProtractorLocator {
    constructor(parent, selector, child, errorHandler) {
        super(parent, selector, errorHandler);
        this.child = child;
    }
    async resolveNativeElement() {
        const cssSelector = this.asCssSelector(this.selector);
        const child = await this.child.nativeElement();
        const webElement = await child.getWebElement();
        return await (0, promised_1.promised)(webElement.getDriver().executeScript(`return arguments[0].closest(arguments[1])`, webElement, cssSelector.value));
    }
    async allNativeElements() {
        return [await this.nativeElement()];
    }
}
//# sourceMappingURL=ProtractorLocator.js.map