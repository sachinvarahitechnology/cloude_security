"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TinyType = exports.TinyTypeOf = void 0;
const ensure_1 = require("./ensure");
const objects_1 = require("./objects");
const predicates_1 = require("./predicates");
/**
 * @desc The {@link TinyTypeOf} can be used to define simple
 * single-value {@link TinyType}s on a single line.
 *
 * It contains a check preventing the constructor argument from being undefined (see {@link isDefined});
 *
 * @experimental
 *
 * @example
 * class Username extends TinyTypeOf<string>() {}
 *
 * @example
 * class Age extends TinyTypeOf<number>() {}
 *
 * @returns a dynamically created base class your tiny type can extend from
 */
function TinyTypeOf() {
    return class extends TinyType {
        constructor(value) {
            super();
            this.value = value;
            (0, ensure_1.ensure)(this.constructor.name, value, (0, predicates_1.isDefined)());
        }
    };
}
exports.TinyTypeOf = TinyTypeOf;
/**
 * @desc The {@link TinyType} abstract class should be used as a base class for your own Tiny Types.
 *
 * If you want the Tiny Type to wrap a single value use the {@link TinyTypeOf} instead as it will save you some keystrokes.
 *
 * @example
 * class FirstName extends TinyTypeOf<string>() {}
 * class LastName  extends TinyTypeOf<string>() {}
 * class Age       extends TinyTypeOf<number>() {}
 *
 * class Person extends TinyType {
 *   constructor(public readonly firstName: FirstName,
 *               public readonly lastName:  LastName,
 *               public readonly age:       Age,
 *   ) {
 *     super();
 *   }
 * }
 */
class TinyType {
    /**
     * @desc Compares two tiny types by value
     *
     * @example <caption>Comparing simple types</caption>
     * class Id extends TinyTypeOf<string>() {}
     *
     * const id = new Id(`3cc0852d-fda7-4f61-874e-0cfadbd6182a`);
     *
     * id.equals(id) === true
     *
     * @example <caption>Comparing complex types recursively</caption>
     * class FirstName extends TinyTypeOf<string>() {}
     * class LastName  extends TinyTypeOf<string>() {}
     * class Age       extends TinyTypeOf<number>() {}
     *
     * class Person extends TinyType {
     *   constructor(public readonly firstName: FirstName,
     *               public readonly lastName:  LastName,
     *               public readonly age:       Age,
     *   ) {
     *     super();
     *   }
     * }
     *
     * const p1 = new Person(new FirstName('John'), new LastName('Smith'), new Age(42)),
     *       p2 = new Person(new FirstName('John'), new LastName('Smith'), new Age(42));
     *
     * p1.equals(p2) === true
     *
     * @param {TinyType} another
     * @returns {boolean}
     */
    equals(another) {
        return (0, objects_1.equal)(this, another);
    }
    /**
     * @desc Serialises the object to its string representation
     *
     * @returns {string}
     */
    toString() {
        return (0, objects_1.stringify)(this);
    }
    /**
     * @desc Serialises the object to a JSON representation.
     *
     * @example
     * class FirstName extends TinyTypeOf<string>() {}
     *
     * const name = new FirstName('Jan');
     *
     * name.toJSON() === 'Jan'
     *
     * @example
     * class FirstName extends TinyTypeOf<string>() {}
     * class LastName  extends TinyTypeOf<string>() {}
     * class Age       extends TinyTypeOf<number>() {}
     *
     * class Person extends TinyType {
     *   constructor(public readonly firstName: FirstName,
     *               public readonly lastName:  LastName,
     *               public readonly age:       Age,
     *   ) {
     *     super();
     *   }
     * }
     *
     * const person = new Person(new FirstName('John'), new LastName('Smith'), new Age(42)),
     *
     * person.toJSON() === { firstName: 'John', lastName: 'Smith', age: 42 }
     *
     * @returns {JSONValue}
     */
    toJSON() {
        const fields = (0, objects_1.significantFieldsOf)(this);
        if (fields.length === 1) {
            return toJSON(this[fields[0]]);
        }
        return fields.reduce((acc, field) => {
            acc[field] = toJSON(this[field]);
            return acc;
        }, {});
    }
}
exports.TinyType = TinyType;
function toJSON(value) {
    switch (true) {
        case value && !!value.toJSON:
            return value.toJSON();
        case value && Array.isArray(value):
            return value.map(v => toJSON(v));
        case value && value instanceof Map:
            return mapToJSON(value);
        case value && value instanceof Set:
            return toJSON(Array.from(value));
        case value && (0, objects_1.isRecord)(value):
            return recordToJSON(value);
        case value && value instanceof Error:
            return errorToJSON(value);
        case isSerialisablePrimitive(value):
            return value;
        default:
            return JSON.stringify(value);
    }
}
function mapToJSON(map) {
    const serialised = Array.from(map, ([key, value]) => [toJSON(key), toJSON(value)]);
    return Object.fromEntries(serialised);
}
function recordToJSON(value) {
    const serialised = Object.entries(value)
        .map(([k, v]) => [toJSON(k), toJSON(v)]);
    return Object.fromEntries(serialised);
}
function errorToJSON(value) {
    return Object.getOwnPropertyNames(value)
        .reduce((serialised, key) => {
        serialised[key] = toJSON(value[key]);
        return serialised;
    }, {});
}
function isSerialisableNumber(value) {
    return typeof value === 'number'
        && !Number.isNaN(value)
        && value !== Number.NEGATIVE_INFINITY
        && value !== Number.POSITIVE_INFINITY;
}
function isSerialisablePrimitive(value) {
    if (['string', 'boolean'].includes(typeof value)) {
        return true;
    }
    if (value === null || value === undefined) {
        return true;
    }
    return isSerialisableNumber(value);
}
//# sourceMappingURL=TinyType.js.map